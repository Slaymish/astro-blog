---
// Particle Background Component for subtle visual interest
---

<div id="particle-canvas"></div>

<style>
  #particle-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: -1;
    opacity: 0.3;
  }
</style>

<script is:inline>
  (function() {
    let animationFrameId = null;
    let colorUpdateInterval = null;
    let cleanupCalled = false;

    function initParticles() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const container = document.getElementById('particle-canvas');

      if (!container || !ctx) return;

      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReducedMotion) {
        return; // Skip particles entirely for users who prefer reduced motion
      }

      container.appendChild(canvas);

      let particles = [];
      let mouse = { x: 0, y: 0 };
      let primaryColor = '#10b981';

      // Spatial grid for O(n) particle connection lookups instead of O(n²)
      const GRID_SIZE = 100; // Connection distance threshold
      const GRID_SIZE_SQ = GRID_SIZE * GRID_SIZE; // Pre-calculated for inner loop performance
      let grid = {};

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      function createParticle() {
        return {
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          size: Math.random() * 2 + 1,
          opacity: Math.random() * 0.5 + 0.2
        };
      }

      function initParticleArray() {
        particles = [];
        const particleCount = Math.min(50, Math.floor((canvas.width * canvas.height) / 15000));
        for (let i = 0; i < particleCount; i++) {
          particles.push(createParticle());
        }
      }

      function getGridKey(x, y) {
        return Math.floor(x / GRID_SIZE) + ',' + Math.floor(y / GRID_SIZE);
      }

      function buildSpatialGrid() {
        grid = {};
        for (let i = 0; i < particles.length; i++) {
          const key = getGridKey(particles[i].x, particles[i].y);
          if (!grid[key]) grid[key] = [];
          grid[key].push(i);
        }
      }

      function getNeighborCells(x, y) {
        const cellX = Math.floor(x / GRID_SIZE);
        const cellY = Math.floor(y / GRID_SIZE);
        const neighbors = [];
        // Check current cell and adjacent cells
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const key = (cellX + dx) + ',' + (cellY + dy);
            if (grid[key]) {
              neighbors.push(...grid[key]);
            }
          }
        }
        return neighbors;
      }

      function updateParticles() {
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;

          // Wrap around edges
          if (p.x < 0) p.x = canvas.width;
          if (p.x > canvas.width) p.x = 0;
          if (p.y < 0) p.y = canvas.height;
          if (p.y > canvas.height) p.y = 0;
        }
      }

      function drawParticles() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Build spatial grid for efficient neighbor lookup
        buildSpatialGrid();

        // Batch draw particles
        ctx.fillStyle = primaryColor;
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          ctx.globalAlpha = p.opacity;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }

        // Draw connections using spatial grid (O(n) instead of O(n²))
        ctx.strokeStyle = primaryColor;
        ctx.lineWidth = 0.5;
        const drawn = new Set();

        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          const neighbors = getNeighborCells(p.x, p.y);

          for (let j = 0; j < neighbors.length; j++) {
            const ni = neighbors[j];
            if (ni <= i) continue; // Skip already checked pairs

            const pairKey = i < ni ? i + '-' + ni : ni + '-' + i;
            if (drawn.has(pairKey)) continue;
            drawn.add(pairKey);

            const other = particles[ni];
            const dx = p.x - other.x;
            const dy = p.y - other.y;
            const distSq = dx * dx + dy * dy;

            if (distSq < GRID_SIZE_SQ) {
              const dist = Math.sqrt(distSq);
              ctx.globalAlpha = (GRID_SIZE - dist) / GRID_SIZE * 0.2;
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(other.x, other.y);
              ctx.stroke();
            }
          }
        }

        ctx.globalAlpha = 1;
      }

      function animate() {
        if (cleanupCalled) return;
        updateParticles();
        drawParticles();
        animationFrameId = requestAnimationFrame(animate);
      }

      // Throttled mouse handler
      let mouseThrottle = false;
      function handleMouseMove(e) {
        if (mouseThrottle) return;
        mouseThrottle = true;

        mouse.x = e.clientX;
        mouse.y = e.clientY;

        // Subtle mouse interaction
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          const dx = mouse.x - p.x;
          const dy = mouse.y - p.y;
          const distSq = dx * dx + dy * dy;

          if (distSq < 10000) { // 100^2
            p.vx += dx * 0.00001;
            p.vy += dy * 0.00001;
          }
        }

        requestAnimationFrame(() => { mouseThrottle = false; });
      }

      function handleResize() {
        resizeCanvas();
        initParticleArray();
      }

      // Update primary color periodically (not every frame)
      function updatePrimaryColor() {
        primaryColor = getComputedStyle(document.documentElement)
          .getPropertyValue('--color-primary-500').trim() || '#10b981';
      }

      // Store handlers for cleanup
      const boundHandleMouseMove = handleMouseMove;
      const boundHandleResize = handleResize;

      document.addEventListener('mousemove', boundHandleMouseMove);
      window.addEventListener('resize', boundHandleResize);

      resizeCanvas();
      initParticleArray();
      updatePrimaryColor();
      colorUpdateInterval = setInterval(updatePrimaryColor, 5000); // Update every 5 seconds instead of 1
      animate();

      // Return cleanup function
      return function cleanup() {
        if (cleanupCalled) return;
        cleanupCalled = true;

        if (animationFrameId !== null) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }

        if (colorUpdateInterval !== null) {
          clearInterval(colorUpdateInterval);
          colorUpdateInterval = null;
        }

        document.removeEventListener('mousemove', boundHandleMouseMove);
        window.removeEventListener('resize', boundHandleResize);

        if (container && canvas.parentNode === container) {
          container.removeChild(canvas);
        }
      };
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        window.__particleCleanup = initParticles();
      });
    } else {
      window.__particleCleanup = initParticles();
    }

    // Cleanup on page navigation/unload
    window.addEventListener('beforeunload', () => {
      if (window.__particleCleanup) {
        window.__particleCleanup();
        window.__particleCleanup = null;
      }
    });
  })();
</script>
