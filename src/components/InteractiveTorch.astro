---
// InteractiveTorch.astro - Interactive torch that reveals hidden cats
import './InteractiveTorch.css';

// Define layout margins and content area (in pixels/percentages relative to page)
const leftMarginWidth = 5; // % - width of left margin
const rightMarginWidth = 5; // % - width of right margin  
const contentStart = 15; // % - where main content starts (accounting for max-w-4xl centering)
const contentEnd = 85; // % - where main content ends
const minTopOffset = 200; // px - minimum distance from top of page
const pageHeight = 1500; // px - approximate page height for positioning
const edgePadding = 50; // px - padding from screen edges so cats are fully visible

// Generate random positions for cats in the side margins
function generateRandomPosition() {
  // Randomly choose left or right margin
  const isLeftMargin = Math.random() < 0.5;
  
  let x, y;
  
  if (isLeftMargin) {
    // Left margin: leftMarginWidth to contentStart, with padding
    x = Math.random() * (contentStart - leftMarginWidth - 3) + leftMarginWidth + 1;
  } else {
    // Right margin: contentEnd to (100 - rightMarginWidth), with padding
    x = Math.random() * (100 - rightMarginWidth - contentEnd - 3) + contentEnd + 1;
  }
  
  // Y position: random position down the page (in pixels), with top and bottom padding
  y = Math.random() * (pageHeight - minTopOffset - edgePadding) + minTopOffset + (edgePadding / 2);
  
  return { x: x + '%', y: y + 'px' };
}

// Generate positions for each cat
const catPositions = [
  generateRandomPosition(), // orange
  generateRandomPosition(), // gray
  generateRandomPosition(), // black
  generateRandomPosition(), // white
  generateRandomPosition()  // brown/tan
];
---

<!-- Torch container - fixed to viewport -->
<div class="torch-game-container fixed inset-0 w-screen h-screen pointer-events-none z-50">
  <div id="torch-container" class="absolute inset-0 pointer-events-none z-50">
    <!-- Torch icon that can be picked up -->
    <div id="torch" class="torch absolute top-5 right-5 w-12 h-16 cursor-grab pointer-events-auto z-60 transition-transform duration-300 opacity-90 filter drop-shadow-lg bg-transparent" data-picked-up="false">
      <img src="/images/flashlight.png" alt="Torch" class="torch-img" />
    </div>
    
    <div id="torch-tooltip" class="torch-tooltip">
      Drag me to find the cats!
    </div>

    <!-- Light effect that follows the torch -->
    <div id="torch-light" class="torch-light"></div>
    
    <!-- Instructions when torch is picked up -->
    <div id="torch-instructions" class="torch-instructions">
      Press R to reset
    </div>
    
    <!-- Cat counter -->
    <div id="cat-counter" class="cat-counter">
      üê± 0/5
    </div>
  </div>
</div>

<!-- Cats positioned as document elements that scroll with the page -->
<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[0].y}; left: ${catPositions[0].x}; z-index: 1001;`} data-cat-type="orange">
  <img src="/images/cats/cat1.png" alt="Orange cat" class="hidden-cat-img" />
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[1].y}; left: ${catPositions[1].x}; z-index: 1001;`} data-cat-type="gray">
  <img src="/images/cats/cat2.png" alt="Gray cat" class="hidden-cat-img" />
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[2].y}; left: ${catPositions[2].x}; z-index: 1001;`} data-cat-type="black">
  <img src="/images/cats/cat3.png" alt="Black cat" class="hidden-cat-img" />
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[3].y}; left: ${catPositions[3].x}; z-index: 1001;`} data-cat-type="white">
  <img src="/images/cats/cat4.png" alt="White cat" class="hidden-cat-img" />
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[4].y}; left: ${catPositions[4].x}; z-index: 1001;`} data-cat-type="brown">
  <img src="/images/cats/cat5.png" alt="Brown cat" class="hidden-cat-img" />
</div>

<script>
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  let torch: HTMLElement | null = null;
  let torchLight: HTMLElement | null = null;
  let torchInstructions: HTMLElement | null = null;
  let catCounter: HTMLElement | null = null;
  let foundCats: Set<string> = new Set();
  let audioContext: AudioContext | null = null;
  let resetText: HTMLElement | null = null;
  let rafPending = false; // throttle flag
  let tooltipTimer: number;
  let tooltip: HTMLElement | null = null;

  // Initialize audio context
  function initAudio() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    }
  }

  // Create different meow sounds for each cat type
  function playMeow(catType: string) {
    if (!audioContext) return;

    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    // Different frequency patterns for each cat
    let frequencies: number[] = [];
    switch (catType) {
      case 'orange':
        frequencies = [300, 400, 350, 500]; // Deep meow
        break;
      case 'gray':
        frequencies = [450, 550, 500, 600]; // Medium meow
        break;
      case 'black':
        frequencies = [280, 350, 320, 450]; // Low meow
        break;
      case 'white':
        frequencies = [500, 650, 600, 750]; // High meow
        break;
      case 'brown':
        frequencies = [350, 450, 400, 550]; // Mid-range meow
        break;
      default:
        frequencies = [400, 500, 450, 550];
    }

    let currentTime = audioContext.currentTime;
    
    // Create a meow pattern
    frequencies.forEach((freq, index) => {
      oscillator.frequency.setValueAtTime(freq, currentTime + index * 0.1);
    });

    // Volume envelope for meow effect
    gainNode.gain.setValueAtTime(0, currentTime);
    gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.05);
    gainNode.gain.exponentialRampToValueAtTime(0.1, currentTime + 0.2);
    gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.4);

    oscillator.type = 'sine';
    oscillator.start(currentTime);
    oscillator.stop(currentTime + 0.4);
  }

  // Play victory sound when all cats are found
  function playVictorySound() {
    if (!audioContext) return;
    
    // Victory melody: C5, E5, G5, C6
    const notes = [523.25, 659.25, 783.99, 1046.50];
    const durations = [0.2, 0.2, 0.2, 0.4];
    
    let currentTime = audioContext.currentTime;
    
    notes.forEach((freq, index) => {
      if (!audioContext) return; // Additional null check for TypeScript
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(freq, currentTime);
      oscillator.type = 'triangle';
      
      // Volume envelope
      gainNode.gain.setValueAtTime(0, currentTime);
      gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + durations[index]);
      
      oscillator.start(currentTime);
      oscillator.stop(currentTime + durations[index]);
      
      currentTime += durations[index];
    });
  }

  // Update cat counter display
  function updateCatCounter() {
    if (catCounter) {
      catCounter.textContent = `üê± ${foundCats.size}/5`;
      
      if (foundCats.size === 5) {
        catCounter.classList.add('complete');
      } else {
        catCounter.classList.remove('complete');
      }
    }
  }

  function getDistance(x1: number, y1: number, x2: number, y2: number): number {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }

  function updateTorchPosition(x: number, y: number) {
    if (torch) {
      torch.style.left = (x - 16) + 'px';
      torch.style.top = (y - 24) + 'px';
    }
    
    if (torchLight) {
      torchLight.style.left = x + 'px';
      torchLight.style.top = y + 'px';
    }
  }

  function checkForHiddenItems(torchX: number, torchY: number) {
    const hiddenItems = document.querySelectorAll('.hidden-item:not(.revealed)');
    
    hiddenItems.forEach((item) => {
      const rect = item.getBoundingClientRect();
      const itemX = rect.left + rect.width / 2;
      const itemY = rect.top + rect.height / 2;
      const distance = getDistance(torchX, torchY, itemX, itemY);
      const revealDistance = parseInt(item.getAttribute('data-reveal-distance') || '80');
      
      if (distance < revealDistance) {
        item.classList.add('revealed');
        const catType = item.getAttribute('data-cat-type') || 'default';
        
        if (!foundCats.has(catType)) {
          foundCats.add(catType);
          initAudio();
          playMeow(catType);
          updateCatCounter();
          
          // Show reset text and play victory sound when all cats are found
          if (foundCats.size === 5) {
            showResetText();
            playVictorySound();
          }
        }
      }
    });
  }

  function showResetText() {
    if (!resetText) {
      resetText = document.createElement('div');
      resetText.className = 'reset-text';
      resetText.textContent = 'All cats found! Press R to reset';
      document.body.appendChild(resetText);
    }
    
    resetText.classList.add('show');
  }

  function resetGame() {
    foundCats.clear();
    
    // Hide all revealed cats
    const revealedItems = document.querySelectorAll('.hidden-item.revealed');
    revealedItems.forEach(item => {
      item.classList.remove('revealed');
    });
    
    // Hide reset text
    if (resetText) {
      resetText.classList.remove('show');
    }
    
    // Reset cat counter
    updateCatCounter();
    if (catCounter) {
      catCounter.classList.remove('show');
    }
    
    // Reset torch position
    if (torch) {
      torch.style.right = '20px';
      torch.style.top = '20px';
      torch.style.left = 'auto';
      torch.setAttribute('data-picked-up', 'false');
    }
    
    // Hide torch light and instructions
    if (torchLight) {
      torchLight.classList.remove('active');
    }
    if (torchInstructions) {
      torchInstructions.classList.remove('show');
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    torch = document.getElementById('torch');
    torchLight = document.getElementById('torch-light');
    torchInstructions = document.getElementById('torch-instructions');
    catCounter = document.getElementById('cat-counter');
    tooltip = document.getElementById('torch-tooltip');

    // show tooltip after 2s if not picked up
    tooltipTimer = window.setTimeout(() => {
      tooltip?.classList.add('show');
    }, 2000);

    if (!torch || !torchLight || !torchInstructions || !catCounter) return;

    // Mouse events for torch dragging
    torch.addEventListener('mousedown', (e: MouseEvent) => {
      // hide tooltip on first grab
      clearTimeout(tooltipTimer);
      tooltip?.classList.remove('show');

      isDragging = true;
      torch!.classList.add('dragging');
      torch!.setAttribute('data-picked-up', 'true');
      
      // Show light effect, instructions, and counter
      torchLight!.classList.add('active');
      torchInstructions!.classList.add('show');
      catCounter!.classList.add('show');
      updateCatCounter();
      
      const rect = torch!.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left - rect.width / 2;
      dragOffset.y = e.clientY - rect.top - rect.height / 2;
      
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e: MouseEvent) => {
      if (isDragging && torch) {
        const x = e.clientX - dragOffset.x;
        const y = e.clientY - dragOffset.y;
        if (!rafPending) {
          rafPending = true;
          requestAnimationFrame(() => {
            handleMove(x,y);
            rafPending = false;
          });
        }
        e.preventDefault();
      }
    });

    document.addEventListener('mouseup', () => {
      if (isDragging && torch && torchLight) {
        isDragging = false;
        torch.classList.remove('dragging');
        torchLight.classList.remove('active');
      }
    });

    // Touch events for mobile
    torch.addEventListener('touchstart', (e: TouchEvent) => {
      clearTimeout(tooltipTimer);
      tooltip?.classList.remove('show');

      if (e.touches.length === 1) {
        isDragging = true;
        torch!.classList.add('dragging');
        torch!.setAttribute('data-picked-up', 'true');
        
        torchLight!.classList.add('active');
        torchInstructions!.classList.add('show');
        catCounter!.classList.add('show');
        updateCatCounter();
        
        const touch = e.touches[0];
        const rect = torch!.getBoundingClientRect();
        dragOffset.x = touch.clientX - rect.left - rect.width / 2;
        dragOffset.y = touch.clientY - rect.top - rect.height / 2;
        
        e.preventDefault();
      }
    });

    document.addEventListener('touchmove', (e: TouchEvent) => {
      if (isDragging && e.touches.length === 1) {
        const t = e.touches[0];
        const x = t.clientX - dragOffset.x;
        const y = t.clientY - dragOffset.y;
        if (!rafPending) {
          rafPending = true;
          requestAnimationFrame(() => {
            handleMove(x,y);
            rafPending = false;
          });
        }
        e.preventDefault();
      }
    });

    document.addEventListener('touchend', () => {
      if (isDragging && torch && torchLight) {
        isDragging = false;
        torch.classList.remove('dragging');
        torchLight.classList.remove('active');
      }
    });

    // Keyboard events
    document.addEventListener('keydown', (e: KeyboardEvent) => {
      if (e.key.toLowerCase() === 'r' && torch && torch.getAttribute('data-picked-up') === 'true') {
        resetGame();
      }
    });
  });

  // consolidate move + hit checks
  function handleMove(x: number, y: number) {
    updateTorchPosition(x, y);
    checkForHiddenItems(x, y);
  }
</script>
