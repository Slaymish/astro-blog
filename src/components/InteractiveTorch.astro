---
// InteractiveTorch.astro - Interactive torch that reveals hidden cats

// Define layout margins and content area (in pixels/percentages relative to page)
const leftMarginWidth = 5; // % - width of left margin
const rightMarginWidth = 5; // % - width of right margin  
const contentStart = 15; // % - where main content starts (accounting for max-w-4xl centering)
const contentEnd = 85; // % - where main content ends
const minTopOffset = 200; // px - minimum distance from top of page
const pageHeight = 1500; // px - approximate page height for positioning

// Generate random positions for cats in the side margins
function generateRandomPosition() {
  // Randomly choose left or right margin
  const isLeftMargin = Math.random() < 0.5;
  
  let x, y;
  
  if (isLeftMargin) {
    // Left margin: leftMarginWidth to contentStart
    x = Math.random() * (contentStart - leftMarginWidth) + leftMarginWidth;
  } else {
    // Right margin: contentEnd to (100 - rightMarginWidth)
    x = Math.random() * (100 - rightMarginWidth - contentEnd) + contentEnd;
  }
  
  // Y position: random position down the page (in pixels)
  y = Math.random() * (pageHeight - minTopOffset) + minTopOffset;
  
  return { x: x + '%', y: y + 'px' };
}

// Generate positions for each cat
const catPositions = [
  generateRandomPosition(), // orange
  generateRandomPosition(), // gray
  generateRandomPosition(), // black
  generateRandomPosition()  // white
];
---

<!-- Torch container - fixed to viewport -->
<div class="torch-game-container">
  <div id="torch-container">
    <!-- Torch icon that can be picked up -->
    <div id="torch" class="torch" data-picked-up="false">
      <div class="torch-handle"></div>
      <div class="torch-flame">
        <div class="flame-inner"></div>
        <div class="flame-outer"></div>
      </div>
    </div>
    
    <!-- Light effect that follows the torch -->
    <div id="torch-light" class="torch-light"></div>
    
    <!-- Instructions when torch is picked up -->
    <div id="torch-instructions" class="torch-instructions">
      Press R to reset
    </div>
  </div>
</div>

<!-- Cats positioned as document elements that scroll with the page -->
<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[0].y}; left: ${catPositions[0].x}; z-index: 1001;`} data-cat-type="orange">
  <div class="hidden-cat pixel-cat orange-cat">
    <div class="cat-ears">
      <div class="cat-ear cat-ear-left"></div>
      <div class="cat-ear cat-ear-right"></div>
    </div>
    <div class="cat-head">
      <div class="cat-eyes">
        <div class="cat-eye cat-eye-left"></div>
        <div class="cat-eye cat-eye-right"></div>
      </div>
      <div class="cat-nose"></div>
      <div class="cat-mouth"></div>
    </div>
    <div class="cat-body">
      <div class="cat-belly"></div>
    </div>
    <div class="cat-tail"></div>
  </div>
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[1].y}; left: ${catPositions[1].x}; z-index: 1001;`} data-cat-type="gray">
  <div class="hidden-cat pixel-cat gray-cat">
    <div class="cat-ears">
      <div class="cat-ear cat-ear-left"></div>
      <div class="cat-ear cat-ear-right"></div>
    </div>
    <div class="cat-head">
      <div class="cat-eyes">
        <div class="cat-eye cat-eye-left"></div>
        <div class="cat-eye cat-eye-right"></div>
      </div>
      <div class="cat-nose"></div>
      <div class="cat-mouth"></div>
    </div>
    <div class="cat-body">
      <div class="cat-belly"></div>
    </div>
    <div class="cat-tail"></div>
  </div>
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[2].y}; left: ${catPositions[2].x}; z-index: 1001;`} data-cat-type="black">
  <div class="hidden-cat pixel-cat black-cat">
    <div class="cat-ears">
      <div class="cat-ear cat-ear-left"></div>
      <div class="cat-ear cat-ear-right"></div>
    </div>
    <div class="cat-head">
      <div class="cat-eyes">
        <div class="cat-eye cat-eye-left"></div>
        <div class="cat-eye cat-eye-right"></div>
      </div>
      <div class="cat-nose"></div>
      <div class="cat-mouth"></div>
    </div>
    <div class="cat-body">
      <div class="cat-belly"></div>
    </div>
    <div class="cat-tail"></div>
  </div>
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[3].y}; left: ${catPositions[3].x}; z-index: 1001;`} data-cat-type="white">
  <div class="hidden-cat pixel-cat white-cat">
    <div class="cat-ears">
      <div class="cat-ear cat-ear-left"></div>
      <div class="cat-ear cat-ear-right"></div>
    </div>
    <div class="cat-head">
      <div class="cat-eyes">
        <div class="cat-eye cat-eye-left"></div>
        <div class="cat-eye cat-eye-right"></div>
      </div>
      <div class="cat-nose"></div>
      <div class="cat-mouth"></div>
    </div>
    <div class="cat-body">
      <div class="cat-belly"></div>
    </div>
    <div class="cat-tail"></div>
  </div>
</div>iv>
    <div class="cat-head">
      <div class="cat-eyes">
        <div class="cat-eye cat-eye-left"></div>
        <div class="cat-eye cat-eye-right"></div>
      </div>
      <div class="cat-nose"></div>
      <div class="cat-mouth"></div>
    </div>
    <div class="cat-body">
      <div class="cat-belly"></div>
    </div>
    <div class="cat-tail"></div>
  </div>
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: fixed; top: ${catPositions[3].y}; left: ${catPositions[3].x}; z-index: 1001;`} data-cat-type="white">
  <div class="hidden-cat pixel-cat white-cat">
    <div class="cat-ears">
      <div class="cat-ear cat-ear-left"></div>
      <div class="cat-ear cat-ear-right"></div>
    </div>
    <div class="cat-head">
      <div class="cat-eyes">
        <div class="cat-eye cat-eye-left"></div>
        <div class="cat-eye cat-eye-right"></div>
      </div>
      <div class="cat-nose"></div>
      <div class="cat-mouth"></div>
    </div>
    <div class="cat-body">
      <div class="cat-belly"></div>
    </div>
    <div class="cat-tail"></div>
  </div>
</div>

<style>
  .torch-game-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 1000;
  }

  .torch-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1000;
  }

  .torch {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 32px;
    height: 52px;
    cursor: grab;
    pointer-events: auto;
    z-index: 1002;
    transition: all 0.3s ease;
    opacity: 0.8;
    filter: drop-shadow(0 0 10px rgba(255, 140, 0, 0.3));
  }

  .torch:hover {
    transform: scale(1.1);
    opacity: 1;
    filter: drop-shadow(0 0 15px rgba(255, 140, 0, 0.5));
  }

  .torch.dragging {
    cursor: grabbing;
    transform: scale(1.2);
    z-index: 1003;
    filter: drop-shadow(0 0 20px rgba(255, 140, 0, 0.7));
  }

  .torch-handle {
    width: 6px;
    height: 20px;
    background: linear-gradient(to bottom, #8B4513 0%, #654321 100%);
    margin: 0 auto 2px;
    border-radius: 3px;
    box-shadow: inset 1px 0 0 rgba(255,255,255,0.2), inset -1px 0 0 rgba(0,0,0,0.3);
  }

  .torch-flame {
    width: 20px;
    height: 24px;
    position: relative;
    margin: 0 auto;
  }

  .flame-outer {
    width: 20px;
    height: 24px;
    background: linear-gradient(45deg, #ff4500 0%, #ff6b35 30%, #ffa500 70%, #ffff00 100%);
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    position: absolute;
    animation: flicker 1s ease-in-out infinite alternate;
    filter: drop-shadow(0 0 8px rgba(255, 140, 0, 0.6));
  }

  .flame-inner {
    width: 12px;
    height: 16px;
    background: linear-gradient(45deg, #ffa500 0%, #ffff00 50%, #ffffff 100%);
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    position: absolute;
    top: 4px;
    left: 50%;
    transform: translateX(-50%);
    animation: flicker 0.8s ease-in-out infinite alternate-reverse;
    opacity: 0.9;
  }

  @keyframes flicker {
    0% { 
      transform: translateX(-50%) scale(0.95) rotate(-2deg);
      opacity: 0.8;
    }
    100% { 
      transform: translateX(-50%) scale(1.05) rotate(2deg);
      opacity: 1;
    }
  }

  .torch-light {
    position: absolute;
    width: 300px;
    height: 300px;
    background: radial-gradient(circle, rgba(255, 215, 0, 0.3) 0%, rgba(255, 140, 0, 0.2) 30%, transparent 70%);
    border-radius: 50%;
    pointer-events: none;
    transform: translate(-50%, -50%);
    z-index: 1001;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .torch-light.active {
    opacity: 1;
  }

  .torch-instructions {
    position: fixed;
    top: 80px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 1003;
    pointer-events: none;
  }

  .torch-instructions.show {
    opacity: 1;
  }

  .hidden-item {
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }

  .hidden-item.revealed {
    opacity: 1;
    animation: bounce 0.6s ease-out;
  }

  @keyframes bounce {
    0% { transform: scale(0.8); opacity: 0; }
    50% { transform: scale(1.1); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
  }

  .pixel-cat {
    width: 32px;
    height: 32px;
    position: relative;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
    cursor: pointer;
  }

  /* Cat structure */
  .cat-ears {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 8px;
  }

  .cat-ear {
    width: 6px;
    height: 6px;
    position: absolute;
    top: 0;
  }

  .cat-ear-left {
    left: 2px;
    transform: rotate(-30deg);
  }

  .cat-ear-right {
    right: 2px;
    transform: rotate(30deg);
  }

  .cat-head {
    position: absolute;
    top: 4px;
    left: 50%;
    transform: translateX(-50%);
    width: 16px;
    height: 12px;
    border-radius: 8px;
  }

  .cat-eyes {
    position: absolute;
    top: 3px;
    left: 50%;
    transform: translateX(-50%);
    width: 12px;
    height: 2px;
  }

  .cat-eye {
    width: 2px;
    height: 2px;
    background: #000;
    position: absolute;
    border-radius: 50%;
  }

  .cat-eye-left {
    left: 2px;
  }

  .cat-eye-right {
    right: 2px;
  }

  .cat-nose {
    position: absolute;
    top: 6px;
    left: 50%;
    transform: translateX(-50%);
    width: 2px;
    height: 1px;
    background: #ff69b4;
  }

  .cat-mouth {
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    width: 4px;
    height: 1px;
    border-left: 1px solid #000;
    border-right: 1px solid #000;
    border-bottom: 1px solid #000;
    border-radius: 0 0 2px 2px;
  }

  .cat-body {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 12px;
    height: 16px;
    border-radius: 6px;
  }

  .cat-belly {
    position: absolute;
    top: 4px;
    left: 50%;
    transform: translateX(-50%);
    width: 8px;
    height: 8px;
    border-radius: 4px;
    opacity: 0.7;
  }

  .cat-tail {
    position: absolute;
    top: 16px;
    right: -2px;
    width: 2px;
    height: 12px;
    border-radius: 1px;
    transform: rotate(15deg);
  }

  /* Cat color variations */
  .orange-cat .cat-ear,
  .orange-cat .cat-head,
  .orange-cat .cat-body,
  .orange-cat .cat-tail {
    background: #ff8c42;
  }

  .orange-cat .cat-belly {
    background: #ffb366;
  }

  .gray-cat .cat-ear,
  .gray-cat .cat-head,
  .gray-cat .cat-body,
  .gray-cat .cat-tail {
    background: #8e8e93;
  }

  .gray-cat .cat-belly {
    background: #c7c7cc;
  }

  .black-cat .cat-ear,
  .black-cat .cat-head,
  .black-cat .cat-body,
  .black-cat .cat-tail {
    background: #2c2c2e;
  }

  .black-cat .cat-belly {
    background: #48484a;
  }

  .white-cat .cat-ear,
  .white-cat .cat-head,
  .white-cat .cat-body,
  .white-cat .cat-tail {
    background: #f2f2f7;
    border: 1px solid #d1d1d6;
  }

  .white-cat .cat-belly {
    background: #ffffff;
  }

  /* Instructions */
  .instructions-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    z-index: 2000;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .instructions-overlay.show {
    opacity: 1;
  }

  .reset-text {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 15px;
    border-radius: 5px;
    font-size: 14px;
    z-index: 1004;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .reset-text.show {
    opacity: 1;
  }
</style>

<script>
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  let torch: HTMLElement | null = null;
  let torchLight: HTMLElement | null = null;
  let torchInstructions: HTMLElement | null = null;
  let foundCats: Set<string> = new Set();
  let audioContext: AudioContext | null = null;
  let resetText: HTMLElement | null = null;

  // Initialize audio context
  function initAudio() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    }
  }

  // Create different meow sounds for each cat type
  function playMeow(catType: string) {
    if (!audioContext) return;

    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    // Different frequency patterns for each cat
    let frequencies: number[] = [];
    switch (catType) {
      case 'orange':
        frequencies = [300, 400, 350, 500]; // Deep meow
        break;
      case 'gray':
        frequencies = [450, 550, 500, 600]; // Medium meow
        break;
      case 'black':
        frequencies = [280, 350, 320, 450]; // Low meow
        break;
      case 'white':
        frequencies = [500, 650, 600, 750]; // High meow
        break;
      default:
        frequencies = [400, 500, 450, 550];
    }

    let currentTime = audioContext.currentTime;
    
    // Create a meow pattern
    frequencies.forEach((freq, index) => {
      oscillator.frequency.setValueAtTime(freq, currentTime + index * 0.1);
    });

    // Volume envelope for meow effect
    gainNode.gain.setValueAtTime(0, currentTime);
    gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.05);
    gainNode.gain.exponentialRampToValueAtTime(0.1, currentTime + 0.2);
    gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.4);

    oscillator.type = 'sine';
    oscillator.start(currentTime);
    oscillator.stop(currentTime + 0.4);
  }

  function getDistance(x1: number, y1: number, x2: number, y2: number): number {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }

  function updateTorchPosition(x: number, y: number) {
    if (torch) {
      torch.style.left = (x - 16) + 'px';
      torch.style.top = (y - 24) + 'px';
    }
    
    if (torchLight) {
      torchLight.style.left = x + 'px';
      torchLight.style.top = y + 'px';
    }
  }

  function checkForHiddenItems(torchX: number, torchY: number) {
    const hiddenItems = document.querySelectorAll('.hidden-item:not(.revealed)');
    
    hiddenItems.forEach((item) => {
      const rect = item.getBoundingClientRect();
      const itemX = rect.left + rect.width / 2;
      const itemY = rect.top + rect.height / 2;
      const distance = getDistance(torchX, torchY, itemX, itemY);
      const revealDistance = parseInt(item.getAttribute('data-reveal-distance') || '80');
      
      if (distance < revealDistance) {
        item.classList.add('revealed');
        const catType = item.getAttribute('data-cat-type') || 'default';
        
        if (!foundCats.has(catType)) {
          foundCats.add(catType);
          initAudio();
          playMeow(catType);
          
          // Show reset text when all cats are found
          if (foundCats.size === 4) {
            showResetText();
          }
        }
      }
    });
  }

  function showResetText() {
    if (!resetText) {
      resetText = document.createElement('div');
      resetText.className = 'reset-text';
      resetText.textContent = 'All cats found! Press R to reset';
      document.body.appendChild(resetText);
    }
    
    resetText.classList.add('show');
  }

  function resetGame() {
    foundCats.clear();
    
    // Hide all revealed cats
    const revealedItems = document.querySelectorAll('.hidden-item.revealed');
    revealedItems.forEach(item => {
      item.classList.remove('revealed');
    });
    
    // Hide reset text
    if (resetText) {
      resetText.classList.remove('show');
    }
    
    // Reset torch position
    if (torch) {
      torch.style.right = '20px';
      torch.style.top = '20px';
      torch.style.left = 'auto';
      torch.setAttribute('data-picked-up', 'false');
    }
    
    // Hide torch light and instructions
    if (torchLight) {
      torchLight.classList.remove('active');
    }
    if (torchInstructions) {
      torchInstructions.classList.remove('show');
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    torch = document.getElementById('torch');
    torchLight = document.getElementById('torch-light');
    torchInstructions = document.getElementById('torch-instructions');

    if (!torch || !torchLight || !torchInstructions) return;

    // Mouse events for torch dragging
    torch.addEventListener('mousedown', (e: MouseEvent) => {
      isDragging = true;
      torch!.classList.add('dragging');
      torch!.setAttribute('data-picked-up', 'true');
      
      // Show light effect and instructions
      torchLight!.classList.add('active');
      torchInstructions!.classList.add('show');
      
      const rect = torch!.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left - rect.width / 2;
      dragOffset.y = e.clientY - rect.top - rect.height / 2;
      
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e: MouseEvent) => {
      if (isDragging && torch) {
        const x = e.clientX - dragOffset.x;
        const y = e.clientY - dragOffset.y;
        
        updateTorchPosition(x, y);
        checkForHiddenItems(x, y);
      }
    });

    document.addEventListener('mouseup', () => {
      if (isDragging && torch) {
        isDragging = false;
        torch.classList.remove('dragging');
      }
    });

    // Touch events for mobile
    torch.addEventListener('touchstart', (e: TouchEvent) => {
      if (e.touches.length === 1) {
        isDragging = true;
        torch!.classList.add('dragging');
        torch!.setAttribute('data-picked-up', 'true');
        
        torchLight!.classList.add('active');
        torchInstructions!.classList.add('show');
        
        const touch = e.touches[0];
        const rect = torch!.getBoundingClientRect();
        dragOffset.x = touch.clientX - rect.left - rect.width / 2;
        dragOffset.y = touch.clientY - rect.top - rect.height / 2;
        
        e.preventDefault();
      }
    });

    document.addEventListener('touchmove', (e: TouchEvent) => {
      if (isDragging && e.touches.length === 1) {
        const touch = e.touches[0];
        const x = touch.clientX - dragOffset.x;
        const y = touch.clientY - dragOffset.y;
        
        updateTorchPosition(x, y);
        checkForHiddenItems(x, y);
        
        e.preventDefault();
      }
    });

    document.addEventListener('touchend', () => {
      if (isDragging && torch) {
        isDragging = false;
        torch.classList.remove('dragging');
      }
    });

    // Keyboard events
    document.addEventListener('keydown', (e: KeyboardEvent) => {
      if (e.key.toLowerCase() === 'r' && foundCats.size === 4) {
        resetGame();
      }
    });
  });
</script>
