---
// InteractiveTorch.astro - Interactive torch that reveals hidden cats

// Define layout margins and content area (in pixels/percentages relative to page)
const leftMarginWidth = 5; // % - width of left margin
const rightMarginWidth = 5; // % - width of right margin  
const contentStart = 15; // % - where main content starts (accounting for max-w-4xl centering)
const contentEnd = 85; // % - where main content ends
const minTopOffset = 200; // px - minimum distance from top of page
const pageHeight = 1500; // px - approximate page height for positioning
const edgePadding = 50; // px - padding from screen edges so cats are fully visible

// Generate random positions for cats in the side margins
function generateRandomPosition() {
  // Randomly choose left or right margin
  const isLeftMargin = Math.random() < 0.5;
  
  let x, y;
  
  if (isLeftMargin) {
    // Left margin: leftMarginWidth to contentStart, with padding
    x = Math.random() * (contentStart - leftMarginWidth - 3) + leftMarginWidth + 1;
  } else {
    // Right margin: contentEnd to (100 - rightMarginWidth), with padding
    x = Math.random() * (100 - rightMarginWidth - contentEnd - 3) + contentEnd + 1;
  }
  
  // Y position: random position down the page (in pixels), with top and bottom padding
  y = Math.random() * (pageHeight - minTopOffset - edgePadding) + minTopOffset + (edgePadding / 2);
  
  return { x: x + '%', y: y + 'px' };
}

// Generate positions for each cat
const catPositions = [
  generateRandomPosition(), // orange
  generateRandomPosition(), // gray
  generateRandomPosition(), // black
  generateRandomPosition(), // white
  generateRandomPosition()  // brown/tan
];
---

<!-- Torch container - fixed to viewport -->
<div class="torch-game-container">
  <div id="torch-container">
    <!-- Torch icon that can be picked up -->
    <div id="torch" class="torch" data-picked-up="false">
      <img src="/images/flashlight.png" alt="Torch" class="torch-img" />
    </div>
    
    <!-- Light effect that follows the torch -->
    <div id="torch-light" class="torch-light"></div>
    
    <!-- Instructions when torch is picked up -->
    <div id="torch-instructions" class="torch-instructions">
      Press R to reset
    </div>
    
    <!-- Cat counter -->
    <div id="cat-counter" class="cat-counter">
      üê± 0/5
    </div>
  </div>
</div>

<!-- Cats positioned as document elements that scroll with the page -->
<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[0].y}; left: ${catPositions[0].x}; z-index: 1001;`} data-cat-type="orange">
  <img src="/images/cats/cat1.png" alt="Orange cat" class="hidden-cat-img" />
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[1].y}; left: ${catPositions[1].x}; z-index: 1001;`} data-cat-type="gray">
  <img src="/images/cats/cat2.png" alt="Gray cat" class="hidden-cat-img" />
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[2].y}; left: ${catPositions[2].x}; z-index: 1001;`} data-cat-type="black">
  <img src="/images/cats/cat3.png" alt="Black cat" class="hidden-cat-img" />
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[3].y}; left: ${catPositions[3].x}; z-index: 1001;`} data-cat-type="white">
  <img src="/images/cats/cat4.png" alt="White cat" class="hidden-cat-img" />
</div>

<div class="hidden-item" data-reveal-distance="80" style={`position: absolute; top: ${catPositions[4].y}; left: ${catPositions[4].x}; z-index: 1001;`} data-cat-type="brown">
  <img src="/images/cats/cat5.png" alt="Brown cat" class="hidden-cat-img" />
</div>

<style>
  .torch-game-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 1000;
  }

  .torch-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1000;
  }

  .torch {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 48px;        /* adjust to your image dimensions */
    height: 64px;       /* adjust to your image dimensions */
    cursor: grab;
    pointer-events: auto;
    z-index: 1002;
    transition: all 0.3s ease;
    opacity: 0.85;
    filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));

    /* new background image instead of CSS shapes */
    background: none;       
  }

  .torch-img {
    width: 100%;
    height: 100%;
    display: block;
    pointer-events: none;
    border: none;              /* remove visible border */
    outline: none;
    background-color: transparent;
  }

  .torch:hover {
    transform: scale(1.1);
    opacity: 1;
    filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.3));
  }

  .torch.dragging {
    cursor: grabbing;
    transform: scale(1.15);
    z-index: 1003;
    filter: drop-shadow(0 6px 16px rgba(0, 0, 0, 0.4));
  }

  .torch-light {
    position: absolute;
    width: 300px;
    height: 300px;
    background: radial-gradient(circle, rgba(255, 215, 0, 0.3) 0%, rgba(255, 140, 0, 0.2) 30%, transparent 70%);
    border-radius: 50%;
    pointer-events: none;
    transform: translate(-50%, -50%);
    z-index: 1001;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .torch-light.active {
    opacity: 1;
  }

  .torch-instructions {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.85);
    color: #fff;
    padding: 12px 20px;
    border-radius: 25px;
    font-size: 14px;
    font-weight: 500;
    opacity: 0;
    transition: all 0.3s ease;
    z-index: 1003;
    pointer-events: none;
    border: 2px solid rgba(255, 140, 0, 0.3);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), 0 0 20px rgba(255, 140, 0, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    text-align: center;
    min-width: 140px;
  }

  .torch-instructions.show {
    opacity: 1;
    transform: translateX(-50%) translateY(-5px);
  }

  .torch-instructions::before {
    content: 'üî•';
    display: inline-block;
    margin-right: 8px;
    font-size: 16px;
  }

  .cat-counter {
    position: fixed;
    top: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.7);
    color: #fff;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    opacity: 0;
    transition: all 0.3s ease;
    z-index: 1003;
    pointer-events: none;
    border: 2px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    text-align: center;
    min-width: 60px;
  }

  .cat-counter.show {
    opacity: 0.8;
  }

  .cat-counter.complete {
    background: rgba(0, 150, 0, 0.8);
    border-color: rgba(0, 255, 0, 0.3);
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  .hidden-item {
    opacity: 0;
    transform: scale(0);  /* start invisible & shrunk */
    pointer-events: none;
  }

  .hidden-item.revealed {
    animation: pop 0.4s ease-out forwards;
  }

  @keyframes pop {
    0% {
      transform: scale(0);
      opacity: 0;
    }
    50% {
      transform: scale(1.2);
      opacity: 1;
    }
    100% {
      transform: scale(1);
      opacity: 1;
    }
  }

  .hidden-cat-img {
    width: 32px;     /* fixed width */
    height: auto;    /* maintain original aspect ratio */
    display: block;
    pointer-events: none;
    border: none;        /* remove any border */
    outline: none;
    background-color: transparent;
  }

  /* Instructions */
  .instructions-overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    z-index: 2000;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .instructions-overlay.show {
    opacity: 1;
  }

  .reset-text {
    position: fixed;
    top: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 100, 0, 0.9);
    color: white;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    z-index: 1004;
    opacity: 0;
    transition: all 0.3s ease;
    border: 2px solid rgba(0, 255, 0, 0.4);
    box-shadow: 0 4px 15px rgba(0, 100, 0, 0.3);
    text-align: center;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  .reset-text.show {
    opacity: 1;
    transform: translateX(-50%) translateY(5px);
  }

  .reset-text::before {
    content: 'üéâ';
    display: inline-block;
    margin-right: 8px;
    font-size: 16px;
  }

  /* hide torch completely on small screens */
  @media (max-width: 640px) {
    .torch-game-container {
      display: none !important;
    }
  }
</style>

<script>
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  let torch: HTMLElement | null = null;
  let torchLight: HTMLElement | null = null;
  let torchInstructions: HTMLElement | null = null;
  let catCounter: HTMLElement | null = null;
  let foundCats: Set<string> = new Set();
  let audioContext: AudioContext | null = null;
  let resetText: HTMLElement | null = null;
  let rafPending = false; // throttle flag

  // Initialize audio context
  function initAudio() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    }
  }

  // Create different meow sounds for each cat type
  function playMeow(catType: string) {
    if (!audioContext) return;

    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    // Different frequency patterns for each cat
    let frequencies: number[] = [];
    switch (catType) {
      case 'orange':
        frequencies = [300, 400, 350, 500]; // Deep meow
        break;
      case 'gray':
        frequencies = [450, 550, 500, 600]; // Medium meow
        break;
      case 'black':
        frequencies = [280, 350, 320, 450]; // Low meow
        break;
      case 'white':
        frequencies = [500, 650, 600, 750]; // High meow
        break;
      case 'brown':
        frequencies = [350, 450, 400, 550]; // Mid-range meow
        break;
      default:
        frequencies = [400, 500, 450, 550];
    }

    let currentTime = audioContext.currentTime;
    
    // Create a meow pattern
    frequencies.forEach((freq, index) => {
      oscillator.frequency.setValueAtTime(freq, currentTime + index * 0.1);
    });

    // Volume envelope for meow effect
    gainNode.gain.setValueAtTime(0, currentTime);
    gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.05);
    gainNode.gain.exponentialRampToValueAtTime(0.1, currentTime + 0.2);
    gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.4);

    oscillator.type = 'sine';
    oscillator.start(currentTime);
    oscillator.stop(currentTime + 0.4);
  }

  // Play victory sound when all cats are found
  function playVictorySound() {
    if (!audioContext) return;
    
    // Victory melody: C5, E5, G5, C6
    const notes = [523.25, 659.25, 783.99, 1046.50];
    const durations = [0.2, 0.2, 0.2, 0.4];
    
    let currentTime = audioContext.currentTime;
    
    notes.forEach((freq, index) => {
      if (!audioContext) return; // Additional null check for TypeScript
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(freq, currentTime);
      oscillator.type = 'triangle';
      
      // Volume envelope
      gainNode.gain.setValueAtTime(0, currentTime);
      gainNode.gain.linearRampToValueAtTime(0.3, currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + durations[index]);
      
      oscillator.start(currentTime);
      oscillator.stop(currentTime + durations[index]);
      
      currentTime += durations[index];
    });
  }

  // Update cat counter display
  function updateCatCounter() {
    if (catCounter) {
      catCounter.textContent = `üê± ${foundCats.size}/5`;
      
      if (foundCats.size === 5) {
        catCounter.classList.add('complete');
      } else {
        catCounter.classList.remove('complete');
      }
    }
  }

  function getDistance(x1: number, y1: number, x2: number, y2: number): number {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }

  function updateTorchPosition(x: number, y: number) {
    if (torch) {
      torch.style.left = (x - 16) + 'px';
      torch.style.top = (y - 24) + 'px';
    }
    
    if (torchLight) {
      torchLight.style.left = x + 'px';
      torchLight.style.top = y + 'px';
    }
  }

  function checkForHiddenItems(torchX: number, torchY: number) {
    const hiddenItems = document.querySelectorAll('.hidden-item:not(.revealed)');
    
    hiddenItems.forEach((item) => {
      const rect = item.getBoundingClientRect();
      const itemX = rect.left + rect.width / 2;
      const itemY = rect.top + rect.height / 2;
      const distance = getDistance(torchX, torchY, itemX, itemY);
      const revealDistance = parseInt(item.getAttribute('data-reveal-distance') || '80');
      
      if (distance < revealDistance) {
        item.classList.add('revealed');
        const catType = item.getAttribute('data-cat-type') || 'default';
        
        if (!foundCats.has(catType)) {
          foundCats.add(catType);
          initAudio();
          playMeow(catType);
          updateCatCounter();
          
          // Show reset text and play victory sound when all cats are found
          if (foundCats.size === 5) {
            showResetText();
            playVictorySound();
          }
        }
      }
    });
  }

  function showResetText() {
    if (!resetText) {
      resetText = document.createElement('div');
      resetText.className = 'reset-text';
      resetText.textContent = 'All cats found! Press R to reset';
      document.body.appendChild(resetText);
    }
    
    resetText.classList.add('show');
  }

  function resetGame() {
    foundCats.clear();
    
    // Hide all revealed cats
    const revealedItems = document.querySelectorAll('.hidden-item.revealed');
    revealedItems.forEach(item => {
      item.classList.remove('revealed');
    });
    
    // Hide reset text
    if (resetText) {
      resetText.classList.remove('show');
    }
    
    // Reset cat counter
    updateCatCounter();
    if (catCounter) {
      catCounter.classList.remove('show');
    }
    
    // Reset torch position
    if (torch) {
      torch.style.right = '20px';
      torch.style.top = '20px';
      torch.style.left = 'auto';
      torch.setAttribute('data-picked-up', 'false');
    }
    
    // Hide torch light and instructions
    if (torchLight) {
      torchLight.classList.remove('active');
    }
    if (torchInstructions) {
      torchInstructions.classList.remove('show');
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    torch = document.getElementById('torch');
    torchLight = document.getElementById('torch-light');
    torchInstructions = document.getElementById('torch-instructions');
    catCounter = document.getElementById('cat-counter');

    if (!torch || !torchLight || !torchInstructions || !catCounter) return;

    // Mouse events for torch dragging
    torch.addEventListener('mousedown', (e: MouseEvent) => {
      isDragging = true;
      torch!.classList.add('dragging');
      torch!.setAttribute('data-picked-up', 'true');
      
      // Show light effect, instructions, and counter
      torchLight!.classList.add('active');
      torchInstructions!.classList.add('show');
      catCounter!.classList.add('show');
      updateCatCounter();
      
      const rect = torch!.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left - rect.width / 2;
      dragOffset.y = e.clientY - rect.top - rect.height / 2;
      
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e: MouseEvent) => {
      if (isDragging && torch) {
        const x = e.clientX - dragOffset.x;
        const y = e.clientY - dragOffset.y;
        if (!rafPending) {
          rafPending = true;
          requestAnimationFrame(() => {
            handleMove(x,y);
            rafPending = false;
          });
        }
        e.preventDefault();
      }
    });

    document.addEventListener('mouseup', () => {
      if (isDragging && torch) {
        isDragging = false;
        torch.classList.remove('dragging');
      }
    });

    // Touch events for mobile
    torch.addEventListener('touchstart', (e: TouchEvent) => {
      if (e.touches.length === 1) {
        isDragging = true;
        torch!.classList.add('dragging');
        torch!.setAttribute('data-picked-up', 'true');
        
        torchLight!.classList.add('active');
        torchInstructions!.classList.add('show');
        catCounter!.classList.add('show');
        updateCatCounter();
        
        const touch = e.touches[0];
        const rect = torch!.getBoundingClientRect();
        dragOffset.x = touch.clientX - rect.left - rect.width / 2;
        dragOffset.y = touch.clientY - rect.top - rect.height / 2;
        
        e.preventDefault();
      }
    });

    document.addEventListener('touchmove', (e: TouchEvent) => {
      if (isDragging && e.touches.length === 1) {
        const t = e.touches[0];
        const x = t.clientX - dragOffset.x;
        const y = t.clientY - dragOffset.y;
        if (!rafPending) {
          rafPending = true;
          requestAnimationFrame(() => {
            handleMove(x,y);
            rafPending = false;
          });
        }
        e.preventDefault();
      }
    });

    document.addEventListener('touchend', () => {
      if (isDragging && torch) {
        isDragging = false;
        torch.classList.remove('dragging');
      }
    });

    // Keyboard events
    document.addEventListener('keydown', (e: KeyboardEvent) => {
      if (e.key.toLowerCase() === 'r' && torch && torch.getAttribute('data-picked-up') === 'true') {
        resetGame();
      }
    });
  });

  // consolidate move + hit checks
  function handleMove(x: number, y: number) {
    updateTorchPosition(x, y);
    checkForHiddenItems(x, y);
  }
</script>
